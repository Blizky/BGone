<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <meta charset="UTF-8" />
  <title>BGone – Offline AI Background Remover</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg-main: #020509;
      --bg-card: #050a12;
      --border-subtle: rgba(255, 255, 255, 0.05);

      --accent: #0099cc;      /* Blizlab blue */
      --accent-soft: rgba(0, 153, 204, 0.18);
      --accent-strong: #00c0ff;

      --title: #ffcc33;       /* yellow */
      --text: #fdfdf9;
      --muted: #9ea4c5;
      --danger: #ff4f6a;

      --checker-a: #181c27;
      --checker-b: #10131f;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, #1b2437 0, #020509 45%, #000 100%);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 0.75rem;
    }

    /* Top-of-page alert – like Multi-Search */
    .page-alert {
      width: 100%;
      max-width: 1180px;
      margin-bottom: 0.5rem;
    }

    .page-alert-inner {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: linear-gradient(90deg, rgba(255, 204, 51, 0.12), rgba(0, 0, 0, 0.9));
      padding: 0.35rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.78rem;
    }

    .page-alert-label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.72rem;
      color: var(--title);
      font-weight: 700;
      padding-right: 0.6rem;
      border-right: 1px solid rgba(255, 255, 255, 0.25);
    }

    .page-alert-text {
      color: var(--muted);
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .page-alert-status {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .page-alert-btn {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(0, 0, 0, 0.35);
      padding: 0.25rem 0.7rem;
      font-size: 0.75rem;
      color: var(--text);
      cursor: pointer;
      white-space: nowrap;
    }

    .page-alert-btn:hover {
      background: rgba(0, 0, 0, 0.75);
      border-color: var(--accent);
    }

    .page-alert-progress {
      width: 110px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      overflow: hidden;
      flex-shrink: 0;
      display: none; /* only shown during download */
    }

    .page-alert-progress-inner {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-strong));
      transition: width 0.15s linear;
    }

    .page-alert-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.6);
      background: #666;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.6);
      display: none; /* only when model cached */
    }

    .page-alert-dot.ready {
      background: #35d96b;
      box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.6),
        0 0 10px rgba(53, 217, 107, 0.9);
    }

    .shell {
      width: min(1180px, 100%);
      background: radial-gradient(circle at top left, #121a2b 0, #050a12 55%, #020509 100%);
      border-radius: 24px;
      box-shadow:
        0 38px 90px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(255, 255, 255, 0.04);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 1rem 1.25rem 0.5rem;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 1rem;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .title-main {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.18em;
      color: var(--title);
      text-transform: uppercase;
    }

    .title-main span.small-cap {
      text-transform: none;
    }

    .title-sub {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .status-chip {
      font-size: 0.78rem;
      color: var(--muted);
      padding: 0.4rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.09);
      background: rgba(4, 8, 18, 0.9);
      max-width: 320px;
      white-space: normal;         /* allow wrapping so full error is visible */
      overflow: visible;
      text-overflow: clip;
      text-align: right;
    }

    main {
      padding: 0.5rem 1.25rem 1.1rem;
      display: grid;
      grid-template-columns: 270px minmax(0, 1fr);
      gap: 0.85rem;
      height: 100%;
    }

    .side {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card {
      background: var(--bg-card);
      border-radius: 18px;
      padding: 0.7rem 0.85rem 0.85rem;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.6);
    }

    .card h2 {
      margin: 0 0 0.45rem;
      font-size: 0.8rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .card label {
      font-size: 0.82rem;
      color: var(--muted);
      display: block;
      margin-bottom: 0.25rem;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.2rem;
    }

    button,
    .fake-input {
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.02);
      color: var(--text);
      font-size: 0.8rem;
      padding: 0.38rem 0.9rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      transition:
        background 0.16s ease,
        border-color 0.16s ease,
        transform 0.05s ease;
      white-space: nowrap;
    }

    button:hover,
    .fake-input:hover {
      background: var(--accent-soft);
      border-color: var(--accent);
    }

    button:active,
    .fake-input:active {
      transform: scale(0.97);
    }

    button.primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #010307;
      border-color: transparent;
      font-weight: 600;
    }

    button.primary[disabled] {
      opacity: 0.45;
      cursor: default;
    }

    button.danger {
      color: var(--danger);
      border-color: rgba(255, 79, 106, 0.7);
    }

    button.small {
      padding-inline: 0.65rem;
      font-size: 0.76rem;
    }

    input[type="file"] {
      display: none;
    }

    input[type="range"] {
      width: 100%;
    }

    .pill-toggle {
      display: flex;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      overflow: hidden;
      margin-top: 0.5rem;
    }

    .pill-toggle button {
      border-radius: 0;
      border: none;
      flex: 1;
      justify-content: center;
      padding-inline: 0.4rem;
      font-size: 0.78rem;
    }

    .pill-toggle button.active {
      background: var(--accent-soft);
      color: var(--accent-strong);
    }

    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      margin-top: 0.35rem;
      line-height: 1.45;
    }

    .progress-text {
      font-size: 0.72rem;
      color: var(--muted);
      margin-top: 0.25rem;
      min-height: 1em;
    }

    .canvas-wrap {
      background:
        repeating-conic-gradient(var(--checker-a) 0% 25%, var(--checker-b) 0% 50%) 50% / 20px 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow:
        0 20px 60px rgba(0, 0, 0, 0.8);
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      background: transparent;
      image-rendering: auto;
      border-radius: 8px;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.7);
    }

    .overlay-msg {
      position: absolute;
      bottom: 0.75rem;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      background: rgba(5, 8, 17, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 0.78rem;
      color: var(--muted);
      pointer-events: none;
      max-width: 90%;
      text-align: center;
    }

    footer {
      padding: 0.2rem 1.3rem 0.75rem;
      font-size: 0.72rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      opacity: 0.8;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 900px) {
      .shell {
        height: auto;
      }
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto;
        height: auto;
      }
      .canvas-wrap {
        min-height: 260px;
      }
      footer {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <!-- Top-of-page note -->
  <div class="page-alert">
    <div class="page-alert-inner">
      <span class="page-alert-label">Note</span>
      <span class="page-alert-text" id="topMessage">
        To use BGone, click “Download model” once to install the AI in this browser (~40&nbsp;MB).
      </span>

      <div class="page-alert-status">
        <button class="page-alert-btn" id="btnPreload">Download model</button>
        <div class="page-alert-progress" id="topProgressWrap">
          <div class="page-alert-progress-inner" id="topProgress"></div>
        </div>
        <div class="page-alert-dot" id="topReadyDot"></div>
      </div>
    </div>
  </div>

  <div class="shell">
    <header>
      <div class="title-block">
        <div class="title-main">
          BG<span class="small-cap">one</span>
        </div>
        <div class="title-sub">Offline AI background remover with manual brush refinement.</div>
      </div>
      <div class="status-chip" id="status">Load an image to begin.</div>
    </header>

    <main>
      <aside class="side">
        <!-- IMAGE CARD -->
        <div class="card">
          <h2>Image</h2>
          <label>Load source</label>
          <div class="btn-row">
            <label class="fake-input" for="fileInput">Choose image…</label>
            <button id="btnClear" class="danger small">Clear</button>
          </div>
          <input id="fileInput" type="file" accept="image/*" />
          <div class="btn-row" style="margin-top:0.5rem;">
            <button id="btnRemove" class="primary">Auto remove background</button>
          </div>
          <div class="btn-row" style="margin-top:0.3rem;">
            <button id="btnDownload" class="small" disabled>Download PNG</button>
          </div>
          <div id="progressText" class="progress-text"></div>
        </div>

        <!-- BRUSH CARD -->
        <div class="card">
          <h2>Brush</h2>
          <label for="brushSize">Brush size</label>
          <input id="brushSize" type="range" min="5" max="80" value="25" />
          <div class="pill-toggle">
            <button id="modeErase" class="active" data-mode="erase">Erase</button>
            <button id="modeRestore" data-mode="restore">Restore</button>
          </div>
          <div class="hint">
            After auto-removal, paint directly on the image:<br>
            • <strong>Erase</strong> hides pixels (more transparency).<br>
            • <strong>Restore</strong> brings back the original pixels.
          </div>
        </div>

        <!-- INFO CARD -->
        <div class="card">
          <h2>Info</h2>
          <div class="hint">
            • Everything runs in your browser; images are never uploaded.<br>
            • Once the model is downloaded, BGone can work offline.<br>
            • Checkerboard = transparent areas in the exported PNG.
          </div>
        </div>
      </aside>

      <section class="canvas-wrap">
        <canvas id="canvas"></canvas>
        <div class="overlay-msg" id="overlayMsg">
          Drop an image here, or use “Choose image…” on the left.
        </div>
      </section>
    </main>

    <footer>
      <div>BGone – local AI cutouts for photos, thumbnails and mockups.</div>
      <div>Made by Alex Blizky – see also <a href="https://blizky.github.io/multisearch/" target="_blank" rel="noreferrer">Multi-Search</a>.</div>
    </footer>
  </div>

  <script type="module">
    import { removeBackground, preload } from "https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.5.8/+esm";

    // DOM refs
    const fileInput      = document.getElementById("fileInput");
    const btnClear       = document.getElementById("btnClear");
    const btnRemove      = document.getElementById("btnRemove");
    const btnDownload    = document.getElementById("btnDownload");

    const btnPreload     = document.getElementById("btnPreload");
    const topMessage     = document.getElementById("topMessage");
    const topProgressWrap= document.getElementById("topProgressWrap");
    const topProgress    = document.getElementById("topProgress");
    const topReadyDot    = document.getElementById("topReadyDot");

    const statusEl       = document.getElementById("status");
    const overlayMsg     = document.getElementById("overlayMsg");
    const progressText   = document.getElementById("progressText");
    const brushSizeEl    = document.getElementById("brushSize");
    const modeEraseBtn   = document.getElementById("modeErase");
    const modeRestoreBtn = document.getElementById("modeRestore");

    const canvas   = document.getElementById("canvas");
    const ctx      = canvas.getContext("2d");
    const hidden   = document.createElement("canvas");
    const hiddenCtx= hidden.getContext("2d");

    let hasImage          = false;
    let working           = false;
    let painting          = false;
    let brushMode         = "erase";
    let resultImageData   = null;
    let originalImageData = null;

    const MODEL_READY_KEY = "bgoneModelReady";

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function setWorking(flag) {
      working = flag;
      btnRemove.disabled = flag || !hasImage;
      fileInput.disabled = flag;
      btnPreload.disabled = flag;
    }

    function setDownloadEnabled(flag) {
      btnDownload.disabled = !flag;
    }

    function setTopProgress(pct) {
      if (pct == null || isNaN(pct)) {
        topProgress.style.width = "0%";
        return;
      }
      const clamped = Math.max(0, Math.min(100, pct));
      topProgress.style.width = clamped + "%";
    }

    function showModelReady() {
      localStorage.setItem(MODEL_READY_KEY, "1");
      btnPreload.style.display = "none";
      topProgressWrap.style.display = "none";
      topReadyDot.style.display = "block";
      topReadyDot.classList.add("ready");
      topMessage.textContent = "Model cached in this browser. BGone can now work offline.";
      setTopProgress(0);
    }

    function checkModelReady() {
      if (localStorage.getItem(MODEL_READY_KEY) === "1") {
        btnPreload.style.display = "none";
        topProgressWrap.style.display = "none";
        topReadyDot.style.display = "block";
        topReadyDot.classList.add("ready");
        topMessage.textContent = "Model cached in this browser. BGone can now work offline.";
        setTopProgress(0);
      }
    }

    function fitImageDimensions(imgWidth, imgHeight, maxWidth = 1400, maxHeight = 900) {
      let w = imgWidth;
      let h = imgHeight;
      const ratio = Math.min(maxWidth / w, maxHeight / h, 1);
      w = Math.round(w * ratio);
      h = Math.round(h * ratio);
      return { w, h };
    }

    function syncImageData() {
      if (!canvas.width || !canvas.height) return;
      resultImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function redrawFromResult() {
      if (!resultImageData) return;
      ctx.putImageData(resultImageData, 0, 0);
    }

    function getCanvasCoords(evt) {
      const rect = canvas.getBoundingClientRect();
      const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
      const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
      const x = ((clientX - rect.left) / rect.width) * canvas.width;
      const y = ((clientY - rect.top) / rect.height) * canvas.height;
      return { x, y };
    }

    function paintCircle(x, y, radius, mode) {
      if (!resultImageData || !originalImageData) return;
      const data = resultImageData.data;
      const orig = originalImageData.data;
      const w = resultImageData.width;
      const h = resultImageData.height;

      const r2 = radius * radius;
      const minX = Math.max(0, Math.floor(x - radius));
      const maxX = Math.min(w - 1, Math.ceil(x + radius));
      const minY = Math.max(0, Math.floor(y - radius));
      const maxY = Math.min(h - 1, Math.ceil(y + radius));

      for (let j = minY; j <= maxY; j++) {
        for (let i = minX; i <= maxX; i++) {
          const dx = i - x;
          const dy = j - y;
          if (dx * dx + dy * dy <= r2) {
            const idx = (j * w + i) * 4;
            if (mode === "erase") {
              data[idx + 3] = 0; // transparent
            } else {
              data[idx    ] = orig[idx    ];
              data[idx + 1] = orig[idx + 1];
              data[idx + 2] = orig[idx + 2];
              data[idx + 3] = orig[idx + 3];
            }
          }
        }
      }
      redrawFromResult();
    }

    async function loadFile(file) {
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        URL.revokeObjectURL(url);
        const { w, h } = fitImageDimensions(img.width, img.height);
        canvas.width = w;
        canvas.height = h;
        hidden.width = w;
        hidden.height = h;

        ctx.clearRect(0, 0, w, h);
        hiddenCtx.clearRect(0, 0, w, h);
        ctx.drawImage(img, 0, 0, w, h);
        hiddenCtx.drawImage(img, 0, 0, w, h);

        originalImageData = hiddenCtx.getImageData(0, 0, w, h);
        syncImageData();
        hasImage = true;
        setWorking(false);
        setDownloadEnabled(true);
        overlayMsg.style.display = "none";
        setStatus(`Image loaded (${img.width} × ${img.height}).`);
        progressText.textContent = "";
      };
      img.onerror = () => {
        setStatus("Error loading image.");
      };
      img.src = url;
    }

    fileInput.addEventListener("change", e => {
      const file = e.target.files && e.target.files[0];
      loadFile(file);
    });

    // Drag & drop
    ["dragenter", "dragover"].forEach(name => {
      canvas.addEventListener(name, e => {
        e.preventDefault();
        e.stopPropagation();
        if (!hasImage) overlayMsg.textContent = "Drop image to load.";
      });
    });

    ["dragleave", "drop"].forEach(name => {
      canvas.addEventListener(name, e => {
        e.preventDefault();
        e.stopPropagation();
        if (!hasImage) {
          overlayMsg.textContent = "Drop an image here, or use “Choose image…”.";
        }
      });
    });

    canvas.addEventListener("drop", e => {
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      loadFile(file);
    });

    // Clear
    btnClear.addEventListener("click", () => {
      hasImage = false;
      canvas.width = 0;
      canvas.height = 0;
      hidden.width = 0;
      hidden.height = 0;
      originalImageData = null;
      resultImageData = null;
      overlayMsg.style.display = "block";
      overlayMsg.textContent = "Drop an image here, or use “Choose image…”.";
      setStatus("Cleared.");
      progressText.textContent = "";
      setDownloadEnabled(false);
    });

    // Preload model
    btnPreload.addEventListener("click", async () => {
      setWorking(true);
      topMessage.textContent = "Downloading AI model… this is a one-time download in this browser.";
      topProgressWrap.style.display = "block";
      setTopProgress(5);
      progressText.textContent = "Preloading AI model…";

      try {
        const config = {
          debug: true,
          progress: (key, current, total) => {
            if (!total) return;
            const pct = (current / total) * 100;
            progressText.textContent = `Downloading ${key}: ${pct.toFixed(1)}%`;
            setTopProgress(pct);
          }
        };
        await preload(config);
        showModelReady();
        progressText.textContent = "";
        setStatus("Model downloaded. Ready to remove backgrounds.");
      } catch (err) {
        console.error(err);
        const msg = (err && (err.message || err.toString?.())) || "Unknown error";
        topMessage.textContent = "Error downloading model: " + msg;
        topProgressWrap.style.display = "none";
        setTopProgress(0);
      } finally {
        setWorking(false);
      }
    });

    // Auto remove background
    btnRemove.addEventListener("click", async () => {
      if (!hasImage || working) return;
      setWorking(true);
      setStatus("Removing background…");
      progressText.textContent = "Preparing image…";

      try {
        const blob = await new Promise(resolve =>
          canvas.toBlob(resolve, "image/png")
        );

        if (!blob) throw new Error("Canvas export returned null blob.");

        const config = {
          debug: true,
          progress: (key, current, total) => {
            if (!total) return;
            const pct = (current / total) * 100;
            progressText.textContent = `Downloading ${key}: ${pct.toFixed(1)}%`;
          }
        };

        const outBlob = await removeBackground(blob, config);
        progressText.textContent = "Compositing result…";

        const url = URL.createObjectURL(outBlob);
        const resultImg = new Image();
        resultImg.onload = () => {
          URL.revokeObjectURL(url);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(resultImg, 0, 0, canvas.width, canvas.height);
          syncImageData();
          setStatus("Background removed. Use the brush to refine, then download PNG.");
          progressText.textContent = "";
          setWorking(false);
          showModelReady(); // if this worked, model is definitely available
        };
        resultImg.onerror = () => {
          setStatus("Error rendering result.");
          progressText.textContent = "";
          setWorking(false);
        };
        resultImg.src = url;
      } catch (err) {
        console.error(err);
        const msg = (err && (err.message || err.toString?.())) || "Unknown error";
        setStatus("Error removing background: " + msg);
        progressText.textContent = "";
        setWorking(false);
      }
    });

    // Brush interactions
    function startPaint(evt) {
      if (!hasImage || working || !resultImageData) return;
      painting = true;
      const { x, y } = getCanvasCoords(evt);
      const radius = parseInt(brushSizeEl.value, 10);
      paintCircle(x, y, radius, brushMode);
      evt.preventDefault();
    }

    function movePaint(evt) {
      if (!painting) return;
      const { x, y } = getCanvasCoords(evt);
      const radius = parseInt(brushSizeEl.value, 10);
      paintCircle(x, y, radius, brushMode);
      evt.preventDefault();
    }

    function endPaint(evt) {
      painting = false;
      evt && evt.preventDefault();
    }

    canvas.addEventListener("mousedown", startPaint);
    canvas.addEventListener("mousemove", movePaint);
    window.addEventListener("mouseup", endPaint);

    canvas.addEventListener("touchstart", startPaint, { passive: false });
    canvas.addEventListener("touchmove", movePaint, { passive: false });
    window.addEventListener("touchend", endPaint, { passive: false });
    window.addEventListener("touchcancel", endPaint, { passive: false });

    modeEraseBtn.addEventListener("click", () => {
      brushMode = "erase";
      modeEraseBtn.classList.add("active");
      modeRestoreBtn.classList.remove("active");
    });

    modeRestoreBtn.addEventListener("click", () => {
      brushMode = "restore";
      modeRestoreBtn.classList.add("active");
      modeEraseBtn.classList.remove("active");
    });

    // Download PNG
    btnDownload.addEventListener("click", () => {
      if (!hasImage || !resultImageData) return;
      const w = canvas.width;
      const h = canvas.height;
      if (!w || !h) return;

      const tmp = document.createElement("canvas");
      const tctx = tmp.getContext("2d");
      tmp.width = w;
      tmp.height = h;
      tctx.putImageData(resultImageData, 0, 0);

      tmp.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bgone.png";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, "image/png");
    });

    // Initial
    setStatus("Load an image to begin.");
    setDownloadEnabled(false);
    checkModelReady();
  </script>
</body>
</html>
