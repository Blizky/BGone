<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BGone ‚Äì Offline AI Background Remover</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --blue: #0099cc;
      --yellow: #ffcc33;
      --white: #fdfdf9;

      --bg-dark: #020509;
      --bg-light: #fdfdf9;

      --text-dark: #fdfdf9;
      --text-light: #020509;

      --card-dark: #050a12;
      --card-light: #ffffff;

      --muted-dark: #9ea4c5;
      --muted-light: #333;

      --checker-dark-a: #181c27;
      --checker-dark-b: #10131f;
      --checker-light-a: #e0e0e0;
      --checker-light-b: #fdfdf9;

      --chip-bg-dark: rgba(255,255,255,0.08);
      --chip-bg-light: rgba(0,0,0,0.06);
      --chip-fg-dark: #eaeaf6;
      --chip-fg-light: #222;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode {
      background: radial-gradient(circle at top, #1b2437 0, var(--bg-dark) 45%, #000 100%);
      color: var(--text-dark);
    }

    body.light-mode {
      background: radial-gradient(circle at top, #ffffff 0, #eaeaea 45%, #dcdcdc 100%);
      color: var(--text-light);
    }

    .shell {
      max-width: 1180px;
      margin: 24px auto;
      border-radius: 24px;
      overflow: hidden;
      transition: background 0.3s ease, box-shadow 0.3s ease;
    }

    body.dark-mode .shell {
      background: radial-gradient(circle at top left, #121a2b 0, var(--card-dark) 55%, var(--bg-dark) 100%);
      box-shadow: 0 38px 90px rgba(0, 0, 0, 0.9);
    }

    body.light-mode .shell {
      background: radial-gradient(circle at top left, #ffffff 0, #f0f0f0 55%, #e0e0e0 100%);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
    }

    header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      padding: 20px 24px 8px 24px;
    }

    .title-main {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.18em;
      color: var(--yellow);
      text-transform: uppercase;
    }

    body.light-mode .title-main {
      color: var(--blue);
    }

    .title-sub {
      font-size: 0.9rem;
      color: var(--muted-dark);
    }

    body.light-mode .title-sub {
      color: var(--muted-light);
    }

    .cards {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      padding: 0 12px 12px 12px;
    }

    .card {
      background: var(--card-dark);
      border-radius: 16px;
      padding: 12px;
      transition: background 0.3s ease, color 0.3s ease, border 0.3s ease;
      border: 1px solid rgba(255,255,255,0.06);
    }

    body.light-mode .card {
      background: var(--card-light);
      color: var(--text-light);
      border: 1px solid rgba(0,0,0,0.06);
    }

    .card h2 {
      margin: 6px 0 8px 0;
      font-size: 1.05rem;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    label {
      font-size: 0.85rem;
      opacity: 0.85;
    }

    input[type="file"],
    input[type="range"],
    button,
    select {
      font-size: 0.95rem;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text-dark);
      transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
    }

    body.light-mode input[type="file"],
    body.light-mode input[type="range"],
    body.light-mode button,
    body.light-mode select {
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.06);
      color: var(--text-light);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.82rem;
      background: var(--chip-bg-dark);
      color: var(--chip-fg-dark);
    }
    body.light-mode .chip {
      background: var(--chip-bg-light);
      color: var(--chip-fg-light);
    }

    .canvas-wrap {
      background: repeating-conic-gradient(var(--checker-dark-a) 0% 25%, var(--checker-dark-b) 0% 50%) 50% / 20px 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin: 12px;
      min-height: 380px;
      position: relative;
      overflow: hidden;
    }

    body.light-mode .canvas-wrap {
      background: repeating-conic-gradient(var(--checker-light-a) 0% 25%, var(--checker-light-b) 0% 50%) 50% / 20px 20px;
      border: 1px solid rgba(0,0,0,0.08);
    }

    canvas {
      display: block;
      margin: 0 auto;
      max-width: 100%;
      height: auto;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      pointer-events: none;
      padding: 16px;
    }

    .overlay .msg {
      background: rgba(0,0,0,0.35);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 0.95rem;
      max-width: 520px;
    }

    body.light-mode .overlay .msg {
      background: rgba(255,255,255,0.7);
      color: #000;
      border: 1px solid rgba(0,0,0,0.15);
    }

    footer {
      padding: 10px 16px 20px 16px;
      font-size: 0.75rem;
      text-align: center;
      color: var(--muted-dark);
    }

    body.light-mode footer {
      color: var(--muted-light);
    }

    /* Theme toggle */
    .theme-toggle {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 1000;
      cursor: pointer;
    }

    .toggle-track {
      width: 60px;
      height: 28px;
      background: #333;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 6px;
      position: relative;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
    }

    .toggle-thumb {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      background: var(--blue);
      border-radius: 50%;
      transition: left 0.25s ease, background 0.25s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    body.light-mode .toggle-thumb {
      left: 34px;
      background: var(--yellow);
    }

    .toggle-icon {
      font-size: 0.9rem;
      color: var(--white);
      z-index: 1;
    }

    body.light-mode .toggle-icon {
      color: var(--text-light);
    }

    /* Toolbar row for actions */
    .toolbar {
      display: flex;
      gap: 8px;
      padding: 0 12px 12px 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 1px 6px;
      border-radius: 6px;
      background: var(--chip-bg-dark);
      color: var(--chip-fg-dark);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 0.8rem;
    }
    body.light-mode .kbd {
      background: var(--chip-bg-light);
      color: var(--chip-fg-light);
      border: 1px solid rgba(0,0,0,0.12);
    }
  </style>
</head>
<body class="dark-mode">
  <div class="shell">
    <header>
      <div>
        <div class="title-main">BGone</div>
        <div class="title-sub">Offline AI background remover with manual brush refinement.</div>
      </div>
      <div class="chip">Local only ‚Ä¢ No uploads</div>
    </header>

    <div class="cards">
      <aside class="card">
        <h2>Image tools</h2>
        <div class="row">
          <label for="fileInput">Load source</label>
          <input id="fileInput" type="file" accept="image/*" />
          <button id="btnRemove" disabled>Auto remove</button>
          <button id="btnDownload" disabled>Download PNG</button>
        </div>
        <div class="row">
          <span class="chip">Drag & drop supported</span>
          <span class="chip">Undo <span class="kbd">‚åòZ</span> ‚Ä¢ Redo <span class="kbd">‚áß‚åòZ</span></span>
        </div>
      </aside>

      <aside class="card">
        <h2>Brush</h2>
        <div class="row">
          <label for="brushSize">Size</label>
          <input id="brushSize" type="range" min="5" max="160" value="36" />
          <button id="modeErase" disabled>Erase</button>
          <button id="modeRestore" disabled>Restore</button>
          <span class="chip">Hold <span class="kbd">Option</span> to toggle</span>
        </div>
      </aside>
    </div>

    <section class="canvas-wrap" id="canvasWrap">
      <canvas id="canvas"></canvas>
      <div class="overlay" id="overlay">
        <div class="msg" id="overlayMsg">Load an image to begin. You can drag & drop or use the file picker.</div>
      </div>
    </section>

    <div class="toolbar">
      <button id="btnFit" disabled>Fit to view</button>
      <button id="btnCenter" disabled>Center</button>
      <select id="checkerSize">
        <option value="20">Checker 20px</option>
        <option value="16">Checker 16px</option>
        <option value="24">Checker 24px</option>
        <option value="32">Checker 32px</option>
      </select>
      <span class="chip">Model loads once ‚Ä¢ Works offline</span>
    </div>

    <footer>
      BGone ‚Äî local AI cutouts for photos, thumbnails and mockups. Made by Alex Blizky.
    </footer>
  </div>

  <!-- Theme toggle -->
  <div id="themeToggle" class="theme-toggle" aria-label="Toggle theme" role="button" tabindex="0">
    <div class="toggle-track">
      <div class="toggle-thumb"></div>
      <div class="toggle-icon moon">üåô</div>
      <div class="toggle-icon sun">‚òÄÔ∏è</div>
    </div>
  </div>

  <script type="module">
    import { removeBackground, preload } from "https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.5.8/+esm";

    // --- Theme toggle ---
    const themeToggle = document.getElementById("themeToggle");
    const body = document.body;

    function applyTheme(mode) {
      body.classList.remove("dark-mode", "light-mode");
      body.classList.add(mode + "-mode");
      localStorage.setItem("bgoneTheme", mode);
    }

    themeToggle.addEventListener("click", () => {
      const current = body.classList.contains("light-mode") ? "light" : "dark";
      const next = current === "light" ? "dark" : "light";
      applyTheme(next);
    });

    const savedTheme = localStorage.getItem("bgoneTheme");
    applyTheme(savedTheme || "dark");

    // --- Elements ---
    const fileInput = document.getElementById("fileInput");
    const btnRemove = document.getElementById("btnRemove");
    const btnDownload = document.getElementById("btnDownload");
    const brushSizeEl = document.getElementById("brushSize");
    const modeEraseBtn = document.getElementById("modeErase");
    const modeRestoreBtn = document.getElementById("modeRestore");
    const btnFit = document.getElementById("btnFit");
    const btnCenter = document.getElementById("btnCenter");
    const checkerSize = document.getElementById("checkerSize");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");
    const overlayMsg = document.getElementById("overlayMsg");
    const canvasWrap = document.getElementById("canvasWrap");

    // --- Offscreen buffers ---
    const originalCanvas = document.createElement("canvas");
    const originalCtx = originalCanvas.getContext("2d");
    const cutoutCanvas = document.createElement("canvas");
    const cutoutCtx = cutoutCanvas.getContext("2d");
    const maskCanvas = document.createElement("canvas");
    const maskCtx = maskCanvas.getContext("2d");

    // --- State ---
    let img = null;
    let hasImage = false;
    let brushSize = parseInt(brushSizeEl.value, 10);
    let brushMode = "erase"; // "erase" removes, "restore" adds
    let painting = false;
    let lastPoint = null;
    let history = [];
    let redoStack = [];
    let viewScale = 1;
    let viewOffset = { x: 0, y: 0 };

    // --- Model preload ---
    overlayMsg.textContent = "Model preloading‚Ä¶ first run may take a moment.";
    preload().then(() => {
      overlayMsg.textContent = "Model ready. Load an image to begin.";
    }).catch(() => {
      overlayMsg.textContent = "Model load failed. You can still load an image; Auto remove may be unavailable.";
    });

    // --- Helpers ---
    function setCanvasSize(w, h) {
      canvas.width = w;
      canvas.height = h;
      originalCanvas.width = w;
      originalCanvas.height = h;
      maskCanvas.width = w;
      maskCanvas.height = h;
      cutoutCanvas.width = w;
      cutoutCanvas.height = h;
    }

    function drawComposite() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!hasImage) return;
      // Base image
      ctx.drawImage(originalCanvas, 0, 0);
      // Apply mask: erase where mask is white (alpha 255) for erase mode; restore draws cutout
      // We use mask as a transparency map to punch-out original image
      const maskData = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < maskData.data.length; i += 4) {
        const m = maskData.data[i]; // grayscale assumed
        // m=255 means erase; m=0 means keep
        if (m > 0) {
          imgData.data[i + 3] = 0;
        }
      }
      ctx.putImageData(imgData, 0, 0);
      // Restore strokes add from cutoutCanvas where mask is 0 but restore strokes marked separately
      // Simpler approach: draw cutout on top clipped by restore layer
      // We‚Äôll maintain restore strokes via negative mask (set m=0 when restore) -> already handled by not erasing
      // If auto-cutout exists, it appears through alpha where original was erased.
      ctx.save();
      ctx.globalCompositeOperation = "destination-over";
      ctx.drawImage(cutoutCanvas, 0, 0);
      ctx.restore();
    }

    function pushHistory() {
      const snap = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
      history.push(snap);
      if (history.length > 100) history.shift();
      redoStack = [];
    }

    function undo() {
      if (history.length === 0) return;
      const current = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
      redoStack.push(current);
      const prev = history.pop();
      maskCtx.putImageData(prev, 0, 0);
      drawComposite();
    }

    function redo() {
      if (redoStack.length === 0) return;
      const next = redoStack.pop();
      const current = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
      history.push(current);
      maskCtx.putImageData(next, 0, 0);
      drawComposite();
    }

    // --- Brush painting ---
    function paintPoint(x, y) {
      maskCtx.globalCompositeOperation = "source-over";
      maskCtx.fillStyle = brushMode === "erase" ? "white" : "black";
      maskCtx.beginPath();
      maskCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
      maskCtx.fill();
    }

    function paintLine(x0, y0, x1, y1) {
      const dx = x1 - x0;
      const dy = y1 - y0;
      const steps = Math.max(Math.abs(dx), Math.abs(dy));
      for (let i = 0; i <= steps; i++) {
        const x = x0 + (dx * i) / steps;
        const y = y0 + (dy * i) / steps;
        paintPoint(x, y);
      }
    }

    function canvasPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
      return { x, y };
    }

    // --- File loading & drag/drop ---
    async function loadImageFile(file) {
      if (!file) return;
      const url = URL.createObjectURL(file);
      const image = new Image();
      image.onload = () => {
        setCanvasSize(image.width, image.height);
        originalCtx.clearRect(0, 0, image.width, image.height);
        originalCtx.drawImage(image, 0, 0);
        maskCtx.clearRect(0, 0, image.width, image.height);
        cutoutCtx.clearRect(0, 0, image.width, image.height);
        img = image;
        hasImage = true;
        overlay.style.display = "none";
        btnRemove.disabled = false;
        btnDownload.disabled = false;
        modeEraseBtn.disabled = false;
        modeRestoreBtn.disabled = false;
        btnFit.disabled = false;
        btnCenter.disabled = false;
        drawComposite();
      };
      image.onerror = () => {
        overlay.style.display = "grid";
        overlayMsg.textContent = "Failed to load image.";
      };
      image.src = url;
    }

    fileInput.addEventListener("change", (e) => {
      const file = e.target.files?.[0];
      loadImageFile(file);
    });

    canvasWrap.addEventListener("dragover", (e) => {
      e.preventDefault();
      overlayMsg.textContent = "Drop image to load‚Ä¶";
    });
    canvasWrap.addEventListener("dragleave", () => {
      overlayMsg.textContent = hasImage ? "" : "Load an image to begin. You can drag & drop or use the file picker.";
    });
    canvasWrap.addEventListener("drop", (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files?.[0];
      loadImageFile(file);
    });

    // --- Auto remove background ---
    btnRemove.addEventListener("click", async () => {
      if (!hasImage) return;
      overlay.style.display = "grid";
      overlayMsg.textContent = "Removing background‚Ä¶";
      try {
        const resultCanvas = await removeBackground(originalCanvas, {
          output: "canvas",
          background: "transparent"
        });
        // Copy result into cutoutCanvas
        cutoutCanvas.width = resultCanvas.width;
        cutoutCanvas.height = resultCanvas.height;
        cutoutCtx.clearRect(0, 0, cutoutCanvas.width, cutoutCanvas.height);
        cutoutCtx.drawImage(resultCanvas, 0, 0);
        overlay.style.display = "none";
        drawComposite();
      } catch (err) {
        overlayMsg.textContent = "Auto remove failed. You can use brush tools.";
      }
    });

    // --- Brush controls ---
    brushSizeEl.addEventListener("input", () => {
      brushSize = parseInt(brushSizeEl.value, 10);
    });

    modeEraseBtn.addEventListener("click", () => {
      brushMode = "erase";
      modeEraseBtn.style.outline = "2px solid var(--blue)";
      modeRestoreBtn.style.outline = "none";
    });

    modeRestoreBtn.addEventListener("click", () => {
      brushMode = "restore";
      modeRestoreBtn.style.outline = "2px solid var(--yellow)";
      modeEraseBtn.style.outline = "none";
    });

    // Option key toggles mode while held
    let optionHeld = false;
    window.addEventListener("keydown", (e) => {
      if (e.key === "Alt") {
        optionHeld = true;
      }
      // Undo/redo
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "z") {
        e.preventDefault();
        if (e.shiftKey) redo(); else undo();
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "Alt") optionHeld = false;
    });

    function activeMode() {
      return optionHeld ? (brushMode === "erase" ? "restore" : "erase") : brushMode;
    }

    // Mouse painting
    canvas.addEventListener("mousedown", (e) => {
      if (!hasImage) return;
      painting = true;
      pushHistory();
      const { x, y } = canvasPos(e);
      lastPoint = { x, y };
      const mode = activeMode();
      maskCtx.fillStyle = mode === "erase" ? "white" : "black";
      paintPoint(x, y);
      drawComposite();
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!painting || !hasImage) return;
      const { x, y } = canvasPos(e);
      const mode = activeMode();
      maskCtx.fillStyle = mode === "erase" ? "white" : "black";
      paintLine(lastPoint.x, lastPoint.y, x, y);
      lastPoint = { x, y };
      drawComposite();
    });

    window.addEventListener("mouseup", () => {
      painting = false;
      lastPoint = null;
    });

    // --- View helpers ---
    function fitToView() {
      if (!hasImage) return;
      const wrapRect = canvasWrap.getBoundingClientRect();
      const maxW = wrapRect.width - 24;
      const maxH = wrapRect.height - 24;
      const scaleX = maxW / canvas.width;
      const scaleY = maxH / canvas.height;
      viewScale = Math.min(scaleX, scaleY, 1);
      canvas.style.transformOrigin = "top left";
      canvas.style.transform = `scale(${viewScale}) translate(${viewOffset.x}px, ${viewOffset.y}px)`;
    }

    function centerView() {
      if (!hasImage) return;
      canvas.style.margin = "0 auto";
    }

    btnFit.addEventListener("click", fitToView);
    btnCenter.addEventListener("click", centerView);

    checkerSize.addEventListener("change", (e) => {
      const size = parseInt(e.target.value, 10);
      const wrap = document.querySelector(".canvas-wrap");
      const dark = `repeating-conic-gradient(var(--checker-dark-a) 0% 25%, var(--checker-dark-b) 0% 50%) 50% / ${size}px ${size}px`;
      const light = `repeating-conic-gradient(var(--checker-light-a) 0% 25%, var(--checker-light-b) 0% 50%) 50% / ${size}px ${size}px`;
      if (body.classList.contains("light-mode")) {
        wrap.style.background = light;
      } else {
        wrap.style.background = dark;
      }
    });

    // --- Download PNG ---
    btnDownload.addEventListener("click", () => {
      if (!hasImage) return;
      const out = document.createElement("canvas");
      out.width = canvas.width;
      out.height = canvas.height;
      const outCtx = out.getContext("2d");
      // Draw the current composite
      // First draw cutout beneath, then original punched by mask alpha
      outCtx.clearRect(0, 0, out.width, out.height);
      outCtx.drawImage(cutoutCanvas, 0, 0);
      // Apply mask to original
      const base = originalCtx.getImageData(0, 0, out.width, out.height);
      const maskData = maskCtx.getImageData(0, 0, out.width, out.height);
      for (let i = 0; i < maskData.data.length; i += 4) {
        const m = maskData.data[i]; // white=erase
        if (m > 0) base.data[i + 3] = 0;
      }
      outCtx.putImageData(base, 0, 0);

      const a = document.createElement("a");
      a.download = "bgone.png";
      a.href = out.toDataURL("image/png");
      a.click();
    });
  </script>
</body>
</html>
