<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BGone ‚Äì Offline AI Background Remover</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --blue: #0099cc;
      --yellow: #ffcc33;
      --white: #fdfdf9;

      --bg-dark: #020509;
      --bg-light: #fdfdf9;

      --text-dark: #fdfdf9;
      --text-light: #020509;

      --card-dark: #050a12;
      --card-light: #ffffff;

      --muted-dark: #9ea4c5;
      --muted-light: #333;

      --checker-dark-a: #181c27;
      --checker-dark-b: #10131f;
      --checker-light-a: #e0e0e0;
      --checker-light-b: #fdfdf9;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode {
      background: radial-gradient(circle at top, #1b2437 0, var(--bg-dark) 45%, #000 100%);
      color: var(--text-dark);
    }

    body.light-mode {
      background: radial-gradient(circle at top, #ffffff 0, #eaeaea 45%, #dcdcdc 100%);
      color: var(--text-light);
    }

    .shell {
      max-width: 1180px;
      margin: auto;
      border-radius: 24px;
      overflow: hidden;
      transition: background 0.3s ease;
    }

    body.dark-mode .shell {
      background: radial-gradient(circle at top left, #121a2b 0, var(--card-dark) 55%, var(--bg-dark) 100%);
      box-shadow: 0 38px 90px rgba(0, 0, 0, 0.9);
    }

    body.light-mode .shell {
      background: radial-gradient(circle at top left, #ffffff 0, #f0f0f0 55%, #e0e0e0 100%);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
    }

    .card {
      background: var(--card-dark);
      border-radius: 18px;
      padding: 1rem;
      margin: 1rem;
      transition: background 0.3s ease;
    }

    body.light-mode .card {
      background: var(--card-light);
      color: var(--text-light);
    }

    .title-main {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.18em;
      color: var(--yellow);
      text-transform: uppercase;
    }

    body.light-mode .title-main {
      color: var(--blue);
    }

    .title-sub {
      font-size: 0.9rem;
      color: var(--muted-dark);
    }

    body.light-mode .title-sub {
      color: var(--muted-light);
    }

    .canvas-wrap {
      background: repeating-conic-gradient(var(--checker-dark-a) 0% 25%, var(--checker-dark-b) 0% 50%) 50% / 20px 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      margin: 1rem;
      min-height: 300px;
    }

    body.light-mode .canvas-wrap {
      background: repeating-conic-gradient(var(--checker-light-a) 0% 25%, var(--checker-light-b) 0% 50%) 50% / 20px 20px;
    }

    footer {
      padding: 1rem;
      font-size: 0.75rem;
      text-align: center;
      color: var(--muted-dark);
    }

    body.light-mode footer {
      color: var(--muted-light);
    }

    /* Theme toggle */
    .theme-toggle {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 1000;
      cursor: pointer;
    }

    .toggle-track {
      width: 60px;
      height: 28px;
      background: #333;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 6px;
      position: relative;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
    }

    .toggle-thumb {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      background: var(--blue);
      border-radius: 50%;
      transition: left 0.25s ease, background 0.25s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    body.light-mode .toggle-thumb {
      left: 34px;
      background: var(--yellow);
    }

    .toggle-icon {
      font-size: 0.9rem;
      color: var(--white);
      z-index: 1;
    }

    body.light-mode .toggle-icon {
      color: var(--text-light);
    }
  </style>
</head>
<body class="dark-mode">
  <div class="shell">
    <header>
      <div>
        <div class="title-main">BGone</div>
        <div class="title-sub">Offline AI background remover with manual brush refinement.</div>
      </div>
    </header>

    <main>
      <aside class="card">
        <h2>Image Tools</h2>
        <p>Load an image, remove background, refine with brush, and download as PNG.</p>
      </aside>
      <aside class="card">
        <h2>Privacy</h2>
        <p>Everything runs locally in your browser. No uploads. Works offline after model download.</p>
      </aside>
      <section class="canvas-wrap">
        <canvas id="canvas"></canvas>
      </section>
    </main>

    <footer>
      BGone ‚Äì local AI cutouts for photos, thumbnails and mockups. Made by Alex Blizky.
    </footer>
  </div>

  <!-- Theme toggle -->
  <div id="themeToggle" class="theme-toggle" aria-label="Toggle theme" role="button" tabindex="0">
    <div class="toggle-track">
      <div class="toggle-thumb"></div>
      <div class="toggle-icon moon">üåô</div>
      <div class="toggle-icon sun">‚òÄÔ∏è</div>
    </div>
  </div>

  <script type="module">
    import { removeBackground, preload } from "https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.5.8/+esm";

    const themeToggle = document.getElementById("themeToggle");
    const body = document.body;

    function applyTheme(mode) {
      body.classList.remove("dark-mode", "light-mode");
      body.classList.add(mode + "-mode");
      localStorage.setItem("bgoneTheme", mode);
    }

    themeToggle.addEventListener("click", () => {
      const current = body.classList.contains("light-mode") ? "light" : "dark";
      const next = current === "light" ? "dark" : "light";
      applyTheme(next);
    });

    const savedTheme = localStorage.getItem("bgoneTheme");
    applyTheme(savedTheme || "dark");

  <script type="module">
    import { removeBackground, preload } from "https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.5.8/+esm";

    // DOM refs
    const fileInput       = document.getElementById("fileInput");
    const btnClear        = document.getElementById("btnClear");
    const btnRemove       = document.getElementById("btnRemove");
    const btnDownload     = document.getElementById("btnDownload");
    const btnPreload      = document.getElementById("btnPreload");
    const topMessage      = document.getElementById("topMessage");
    const topProgressWrap = document.getElementById("topProgressWrap");
    const topProgress     = document.getElementById("topProgress");
    const topReadyDot     = document.getElementById("topReadyDot");
    const statusEl        = document.getElementById("status");
    const overlayMsg      = document.getElementById("overlayMsg");
    const progressText    = document.getElementById("progressText");
    const brushSizeEl     = document.getElementById("brushSize");
    const modeEraseBtn    = document.getElementById("modeErase");
    const modeRestoreBtn  = document.getElementById("modeRestore");
    const toastEl         = document.getElementById("toast");

    // Main display canvas
    const canvas   = document.getElementById("canvas");
    const ctx      = canvas.getContext("2d");

    // Offscreen originals and mask
    const originalCanvas = document.createElement("canvas");
    const originalCtx    = originalCanvas.getContext("2d");

    const maskCanvas     = document.createElement("canvas");
    const maskCtx        = maskCanvas.getContext("2d");

    // State
    const MODEL_READY_KEY = "bgoneModelReady";
    let hasImage        = false;
    let working         = false;
    let brushMode       = "erase"; // "erase" or "restore"
    let painting        = false;
    let lastPointer     = null;

    // History (mask snapshots)
    const history = { stack: [], redos: [], limit: 30 };
    function pushHistory() {
      if (!hasImage) return;
      try {
        const snap = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
        history.stack.push(snap);
        if (history.stack.length > history.limit) history.stack.shift();
        history.redos.length = 0;
      } catch (_e) {}
    }
    function undo() {
      if (history.stack.length <= 1) return;
      const current = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
      const prev = history.stack[history.stack.length - 2];
      history.redos.push(current);
      history.stack.pop();
      maskCtx.putImageData(prev, 0, 0);
      render();
      setStatus("Undid last stroke.");
    }
    function redo() {
      if (history.redos.length === 0) return;
      const redoImg = history.redos.pop();
      history.stack.push(redoImg);
      maskCtx.putImageData(redoImg, 0, 0);
      render();
      setStatus("Redid stroke.");
    }

    // UI helpers
    function setStatus(text) { statusEl.textContent = text; }
    function setWorking(flag) {
      working = flag;
      btnRemove.disabled = flag || !hasImage;
      fileInput.disabled = flag;
      btnPreload.disabled = flag;
    }
    function setDownloadEnabled(flag) { btnDownload.disabled = !flag; }
    function setTopProgress(pct) {
      if (pct == null || isNaN(pct)) { topProgress.style.width = "0%"; return; }
      const clamped = Math.max(0, Math.min(100, pct));
      topProgress.style.width = clamped + "%";
    }
    function showModelReadyUI() {
      btnPreload.style.display = "none";
      topProgressWrap.style.display = "none";
      topReadyDot.style.display = "block";
      topReadyDot.classList.add("ready");
      topMessage.textContent = "Model cached in this browser. BGone can now work offline.";
      setTopProgress(0);
    }
    function showToast(msg, type = "info", ttl = 3500) {
      toastEl.textContent = msg;
      toastEl.classList.toggle("error", type === "error");
      toastEl.style.display = "block";
      setTimeout(() => { toastEl.style.display = "none"; }, ttl);
    }

    function checkModelReady() {
      if (localStorage.getItem(MODEL_READY_KEY) === "1") showModelReadyUI();
    }
    function markModelReady() {
      localStorage.setItem(MODEL_READY_KEY, "1");
      showModelReadyUI();
    }

    // Fit dimensions preserving aspect ratio within bounds
    function fitImageDimensions(imgWidth, imgHeight, maxWidth = 1400, maxHeight = 900) {
      let w = imgWidth, h = imgHeight;
      const ratio = Math.min(maxWidth / w, maxHeight / h, 1);
      w = Math.round(w * ratio); h = Math.round(h * ratio);
      return { w, h };
    }

    // Render pipeline: draw original, then apply mask via compositing
    function render() {
      if (!hasImage) return;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // Draw original
      ctx.globalCompositeOperation = "source-over";
      ctx.drawImage(originalCanvas, 0, 0, w, h);

      // Apply mask (destination-in keeps only the intersection)
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(maskCanvas, 0, 0, w, h);

      // Reset comp op
      ctx.globalCompositeOperation = "source-over";
    }

    // Initialize mask to fully opaque or to model output alpha
    function initMaskFromImage(img) {
      const w = canvas.width, h = canvas.height;
      maskCanvas.width = w; maskCanvas.height = h;
      // Start with fully opaque mask (white)
      maskCtx.clearRect(0, 0, w, h);
      maskCtx.fillStyle = "#fff";
      maskCtx.fillRect(0, 0, w, h);
      pushHistory();
    }
    function initMaskFromResultBlob(blob) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(blob);
        const resultImg = new Image();
        resultImg.onload = () => {
          URL.revokeObjectURL(url);
          const { w, h } = { w: canvas.width, h: canvas.height };
          // Draw result onto a temp canvas to read alpha
          const temp = document.createElement("canvas");
          temp.width = w; temp.height = h;
          const tctx = temp.getContext("2d");
          tctx.drawImage(resultImg, 0, 0, w, h);

          const imgData = tctx.getImageData(0, 0, w, h);
          const maskData = maskCtx.createImageData(w, h);
          // Build mask from result alpha (255 = keep, 0 = remove)
          const src = imgData.data, dst = maskData.data;
          for (let i = 0; i < src.length; i += 4) {
            const a = src[i + 3];
            dst[i] = 255; dst[i + 1] = 255; dst[i + 2] = 255; dst[i + 3] = a;
          }
          maskCtx.putImageData(maskData, 0, 0);
          pushHistory();
          resolve();
        };
        resultImg.onerror = () => { URL.revokeObjectURL(url); reject(new Error("Error rendering result.")); };
        resultImg.src = url;
      });
    }

    // Load file into originals and mask
    async function loadFile(file) {
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        URL.revokeObjectURL(url);

        const { w, h } = fitImageDimensions(img.width, img.height);
        canvas.width = w; canvas.height = h;
        originalCanvas.width = w; originalCanvas.height = h;

        originalCtx.clearRect(0, 0, w, h);
        originalCtx.drawImage(img, 0, 0, w, h);

        hasImage = true;
        setWorking(false);
        setDownloadEnabled(true);
        overlayMsg.style.display = "none";
        setStatus(`Image loaded (${img.width} √ó ${img.height}).`);
        progressText.textContent = "";

        // Initialize mask fully opaque to allow manual erase before AI
        initMaskFromImage(img);
        render();
      };
      img.onerror = () => {
        setStatus("Error loading image.");
        showToast("Could not load that image. Try a different file.", "error");
      };
      img.src = url;
    }

    // Pointer utilities
    function getCanvasPointer(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = ((evt.clientX - rect.left) / rect.width) * canvas.width;
      const y = ((evt.clientY - rect.top) / rect.height) * canvas.height;
      return { x, y };
    }

    function drawStamp(x, y, radius) {
      // We draw white circles on mask; erase uses destination-out to cut holes; restore uses source-over to add white.
      maskCtx.save();
      maskCtx.lineCap = "round";
      maskCtx.lineJoin = "round";
      maskCtx.fillStyle = "#fff";
      maskCtx.strokeStyle = "#fff";

      if (brushMode === "erase") {
        maskCtx.globalCompositeOperation = "destination-out";
      } else {
        maskCtx.globalCompositeOperation = "source-over";
      }

      maskCtx.beginPath();
      maskCtx.arc(x, y, radius, 0, Math.PI * 2);
      maskCtx.fill();
      maskCtx.restore();
    }

    function drawStroke(from, to, radius) {
      // Draw along the path for smooth strokes
      maskCtx.save();
      maskCtx.lineCap = "round";
      maskCtx.lineJoin = "round";
      maskCtx.lineWidth = radius * 2;
      maskCtx.strokeStyle = "#fff";
      if (brushMode === "erase") {
        maskCtx.globalCompositeOperation = "destination-out";
      } else {
        maskCtx.globalCompositeOperation = "source-over";
      }
      maskCtx.beginPath();
      maskCtx.moveTo(from.x, from.y);
      maskCtx.lineTo(to.x, to.y);
      maskCtx.stroke();
      maskCtx.restore();
    }

    function startPaint(evt) {
      if (!hasImage || working) return;
      painting = true;
      canvas.setPointerCapture(evt.pointerId);
      const p = getCanvasPointer(evt);
      lastPointer = p;
      const radius = parseInt(brushSizeEl.value, 10);
      drawStamp(p.x, p.y, radius);
      render();
      evt.preventDefault();
    }
    function movePaint(evt) {
      if (!painting) return;
      const p = getCanvasPointer(evt);
      const radius = parseInt(brushSizeEl.value, 10);
      drawStroke(lastPointer, p, radius);
      lastPointer = p;
      render();
      evt.preventDefault();
    }
    function endPaint(evt) {
      if (!painting) return;
      painting = false;
      lastPointer = null;
      pushHistory();
      evt && evt.preventDefault();
    }

    // Download PNG of composited result
    function downloadPNG() {
      if (!hasImage) return;
      const tmp = document.createElement("canvas");
      tmp.width = canvas.width;
      tmp.height = canvas.height;
      const tctx = tmp.getContext("2d");
      // Draw original then apply mask (same as render)
      tctx.drawImage(originalCanvas, 0, 0, tmp.width, tmp.height);
      tctx.globalCompositeOperation = "destination-in";
      tctx.drawImage(maskCanvas, 0, 0, tmp.width, tmp.height);
      tctx.globalCompositeOperation = "source-over";

      tmp.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bgone.png";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, "image/png");
    }

    // Events
    fileInput.addEventListener("change", e => {
      const file = e.target.files && e.target.files[0];
      loadFile(file);
    });

    // Drag & drop
    ["dragenter", "dragover"].forEach(name => {
      canvas.addEventListener(name, e => {
        e.preventDefault(); e.stopPropagation();
        if (!hasImage) overlayMsg.textContent = "Drop image to load.";
      });
    });
    ["dragleave", "drop"].forEach(name => {
      canvas.addEventListener(name, e => {
        e.preventDefault(); e.stopPropagation();
        if (!hasImage) overlayMsg.textContent = "Drop an image here, or use ‚ÄúChoose image‚Ä¶‚Äù.";
      });
    });
    canvas.addEventListener("drop", e => {
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      loadFile(file);
    });

    // Clear
    btnClear.addEventListener("click", () => {
      hasImage = false;
      canvas.width = 0; canvas.height = 0;
      originalCanvas.width = 0; originalCanvas.height = 0;
      maskCanvas.width = 0; maskCanvas.height = 0;
      overlayMsg.style.display = "block";
      overlayMsg.textContent = "Drop an image here, or use ‚ÄúChoose image‚Ä¶‚Äù.";
      setStatus("Cleared.");
      progressText.textContent = "";
      setDownloadEnabled(false);
      history.stack.length = 0;
      history.redos.length = 0;
    });

    // Preload model
    btnPreload.addEventListener("click", async () => {
      setWorking(true);
      topMessage.textContent = "Downloading AI model‚Ä¶ this is a one-time download in this browser.";
      topProgressWrap.style.display = "block";
      setTopProgress(5);
      progressText.textContent = "Preloading AI model‚Ä¶";
      try {
        const config = {
          debug: true,
          progress: (key, current, total) => {
            if (!total) return;
            const pct = (current / total) * 100;
            progressText.textContent = `Downloading ${key}: ${pct.toFixed(1)}%`;
            setTopProgress(pct);
          }
        };
        await preload(config);
        markModelReady();
        progressText.textContent = "";
        setStatus("Model downloaded. Ready to remove backgrounds.");
        showToast("Model downloaded. BGone works offline now.");
      } catch (err) {
        const msg = (err && (err.message || err.toString?.())) || "Unknown error";
        topMessage.textContent = "Error downloading model: " + msg;
        topProgressWrap.style.display = "none";
        setTopProgress(0);
        showToast("Model download failed. Please try again.", "error");
      } finally {
        setWorking(false);
      }
    });

    // Auto remove background
    btnRemove.addEventListener("click", async () => {
      if (!hasImage || working) return;
      setWorking(true);
      setStatus("Removing background‚Ä¶");
      progressText.textContent = "Preparing image‚Ä¶";

      try {
        const blob = await new Promise(resolve => originalCanvas.toBlob(resolve, "image/png"));
        if (!blob) throw new Error("Canvas export returned null blob.");

        const config = {
          debug: true,
          progress: (key, current, total) => {
            if (!total) return;
            const pct = (current / total) * 100;
            progressText.textContent = `Downloading ${key}: ${pct.toFixed(1)}%`;
          }
        };

        const outBlob = await removeBackground(blob, config);
        progressText.textContent = "Applying mask‚Ä¶";

        await initMaskFromResultBlob(outBlob);
        render();
        setStatus("Background removed. Use the brush to refine, then download PNG.");
        progressText.textContent = "";
        markModelReady(); // if this worked, model is available
      } catch (err) {
        const msg = (err && (err.message || err.toString?.())) || "Unknown error";
        setStatus("Error removing background: " + msg);
        progressText.textContent = "";
        showToast("Background removal failed. Try re-downloading the model or another image.", "error");
      } finally {
        setWorking(false);
      }
    });

    // Brush interactions via Pointer Events
    canvas.addEventListener("pointerdown", startPaint, { passive: false });
    canvas.addEventListener("pointermove", movePaint, { passive: false });
    canvas.addEventListener("pointerup", endPaint, { passive: false });
    canvas.addEventListener("pointercancel", endPaint, { passive: false });
    canvas.addEventListener("pointerleave", endPaint, { passive: false });

    // Mode toggles
    function setBrushMode(mode) {
      brushMode = mode;
      const eraseActive = mode === "erase";
      modeEraseBtn.classList.toggle("active", eraseActive);
      modeRestoreBtn.classList.toggle("active", !eraseActive);
      modeEraseBtn.setAttribute("aria-selected", eraseActive ? "true" : "false");
      modeRestoreBtn.setAttribute("aria-selected", eraseActive ? "false" : "true");
    }
    modeEraseBtn.addEventListener("click", () => setBrushMode("erase"));
    modeRestoreBtn.addEventListener("click", () => setBrushMode("restore"));

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      if (working) return;
      switch (e.key.toLowerCase()) {
        case "e": setBrushMode("erase"); setStatus("Brush: Erase"); break;
        case "r": setBrushMode("restore"); setStatus("Brush: Restore"); break;
        case "z": undo(); break;
        case "y": redo(); break;
        default: break;
      }
    });

    // Download
    btnDownload.addEventListener("click", downloadPNG);

    // Initial
    setStatus("Load an image to begin.");
    setDownloadEnabled(false);
    checkModelReady();
  </script>
  </script>
</body>
</html>
